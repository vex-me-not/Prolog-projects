% Askisi 1 
% Α.Μ. : 1115201700187
% Χαρίσης Νικόλαος

% Μηκος λιστας (για καλου και για κακου)
list_length([],0).
list_length([_|Tail],N) :-
	list_length(Tail,N1),
	N is N1 + 1.

% Τελευταιο στοιχειο λιστας
last_el(X,[X]).
last_el(X,[_|L]) :- last_el(X,L).

% Η find της διαλεξης
find_cons_pref([X], [X], []).
find_cons_pref([X,X|List], [X|Pref], Rest) :- 
	find_cons_pref([X|List], Pref, Rest).
find_cons_pref([X, Y|List], [X], [Y|List]) :- X \= Y.

% Δημιουργια λιστας με την επαναληψη ενος στοιχειο Ν φορες
repeat(_, 0, []).
repeat(X, N, [X|L]) :- 
	N > 0, 
	N1 is N - 1, 
	repeat(X, N1, L).


% Decode
decode_rl([], []).      % Η κενη λιστα αποκωδικοποιειται στην κενη λιστα
decode_rl([Head|Tail], DecList) :-
	decode_rl(Head, LH),      % αποκωδικοποιουμε την κεφαλη(Head) στην δικη της λιστα (LH)
	LH \= [],                 
	decode_rl(Tail, LT),      % αποκωδικοποιουμε την ουρα(Tail) στην δικη της λιστα(LT)
	append(LH, LT, DecList).  % συνδιαζουμε της 2 παραγωμενες λιστες LH και LT στην DecList
decode_rl((X, N), DecList) :- 
	N > 1,                    % το Ν πρεπει να ειναι μεγαλυτερο του 1
	repeat(X, N, DecList).    % Η DecList προκυπτει αν επαναλαβουμε το στοιχειο Χ N φορες
decode_rl(X, [X]) :-
	X \= (_,_),         % Το X δεν  πρεπει να ειναι της μορφης (Χ,Ν)
	X \= [],            % Tο X δεν πρεπει να ειναι η κενη λιστα
	X \= [_ | _].       % ή οποιαδηποτε αλλη λιστα


% Encode
encode_rl([],[]).     % Η κενη λιστα κωδικοποειται στην κενη λιστα
encode_rl(List,EncList) :- 
	find_cons_pref(List,Pref,Rest), % Χωριζουμε τη λιστα σε Pref και Rest
	encode_rl(Rest,RestEnc),        % Κωδικοποιουμε την Pref
	RestEnc \= [],
	encode_rl(Pref,PrefEnc),        % Κωδικοπουμε την Rest
	append(PrefEnc,RestEnc,EncList). % συνδιαζουμε τις 2 λιστες που προκυπτουν
encode_rl([Head|Tail],[(Head,N)]) :- % οι λιστες Pref που εχουν προκυψει απ το find_cons_pref κωδικοποιουνται σε μια λιστα που εχει την πλειαδα (Χ,Ν) 
	last_el(Last,[Head|Tail]),
	Head == Last,                    % Οι λιστες Pref εχουν ολα τα στοιχεια τους ιδια,αρα και την κεφαλη με την ουρα
	list_length([Head|Tail],N),      % Στο Ν μπαινει το μηκος την Pref λιστας
	N > 1.							 % Μονο αν εχουν πανω απο 1 στοιχεια
encode_rl([X],[X]) :- % Ενα μονο στοιχειο που δεν ειναι λιστα και δεν ειναι πλειαδα κωδικοποιειται σε μια λιστα που περιεχει μονο αυτο το στοιχειο  
	X \= (_,_),
	X \= [],
	X \= [_ | _].



/* 
	Η απάντηση που παίρνω στην ερωτηση "encode_rl([p(3),p(X),q(X),q(Y),q(4)], L)." ειναι η
		X = 3
		Y = 3
		L = [(p(3), 2), (q(3), 2), q(4)] 

Αυτό οφείλεται στους κανόνες της ενοποίησης των μεταβλητών με σταθερες και της ενοποιησης των μεταβλητων μεταξυ τους. Στην δική μας περίπτωση, 
αρχίκα η μεταβλητη Χ ενοποιειται με την σταθερα 3 και παιρνει την τιμη αυτη ,εξαιτιας του p(X). Έτσι, το q(X) γινεται q(3), με αποτέλεσμα το Y
να ενοποιειται και αυτο με την σταθερα 3 και να παιρνει την τιμή αυτη, εξαιτιας του q(Y). Ενδεικτικό είναι ότι, αν αλλάζαμε το ερωτημα μας
στο "encode_rl([q(Y),q(4),p(X),p(3),q(X)], L)." θα παίρναμε ως απάντηση 
	Y = 4
	X = 3
	L = [(q(4), 2), (p(3), 2), q(3)]
Αυτό οφείλεται στο γεγονός ότι στο αλλαγμένο ερώτημα πρώτα θα ενοποιούταν το Y με το 4, εξαιτίας του q(Y) και μετά θα ενοιποιούταν το Χ με το 3,
εξαιτίας του p(X).
Αν δε, καναμε την ερωτηση "encode_rl([q(Y),q(4),q(X),p(X),p(3)], L)." θα παιρναμε την απάντηση
	Y = 4
	X = 4
	L = [(q(4), 3), p(4), p(3)]
μιας και τωρα θα ενοποιουταν το Υ με το 4 εξαιτιας του q(Y) και το Χ θα ενοποιουταν και αυτο με το 4 εξαιτιας του q(X).
Αλλα στην δικια μας περιπτωση θα περναμε αυτο που αναφερεται στην αρχη.

*/